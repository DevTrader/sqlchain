#!/usr/bin/env python

import os, sys, signal, pwd, random, string, shutil, json
from getpass import getpass
import MySQLdb as db
from sqlchain.democvt import democvt

DATA_DIR = 0
BLKDAT_DIR = 1
DAEMON_BIN = 2
DEF_COIN_USER = 3
DEF_RPC_PORT = 4
DEF_API_PORT = 5
CAN_PRUNE = 6
CAN_BLKDAT = 7

coin_setup = {
    'bitcoin': [ 'bitcoin',  '',         'bitcoind',  'btc', 8332,  8085,  True, True ],
    'testnet': [ 'bitcoin',  'testnet3', 'bitcoind',  'btc', 18332, 18085, True, True ],
    'litecoin':[ 'litecoin', '',         'litecoind', 'ltc', 10332, 8086,  True, False ],
    'reddcoin':[ 'reddcoin', '',         'reddcoind', 'rdd', 45443, 8087,  False, False ]
}
def coin_var(IDX):
    return coin_setup[cointype][IDX]
cointype = ''
sqlroot = "/var/data/sqlchain"

def sigterm_handler(_signo, _stack_frame):
    print "\nClean shutdown"
    sys.exit(0)

signal.signal(signal.SIGINT, sigterm_handler)

print """\nThis program will configure sqlChain for your system.
It can optionally create and initialize the MySQL database. It will ask a series of questions
and then create the database, user, init and cfg files. Re-running this will overwrite options
including passwords but does not clear the DB or remove old files.\n"""

if not os.path.exists('/usr/local/share/sqlchain'):
    print "You need to install sqlchain before running this program.\neg. sudo pip install sqlchain\n"
    sys.exit(0)
print "Defaults are shown in [brackets]. Just hit enter to accept the default.\n"
if os.geteuid() != 0:
    print "You need to run with root/sudo privileges - try again."
    sys.exit(0)
go = raw_input( "Continue [Y]/N:" ) or 'Y'
if go.upper() != 'Y':
    sys.exit(0)

while cointype not in coin_setup.keys():
    print """\nsqlchaind can support several coin types / blockchains.\n\nCurrent options are: %s.\n""" % ', '.join(coin_setup.keys()[::-1])
    cointype = raw_input( "Enter cointype (blockchain) to use [bitcoin]:" ) or 'bitcoin'

coindir = raw_input( "\nEnter the %s data directory [/var/data/%s]:" % (cointype,coin_var(DATA_DIR))) or "/var/data/"+coin_var(DATA_DIR)
coinboot = raw_input( "Start %s at system boot Y/N/[No Change]:" % coin_var(DAEMON_BIN) ) or '#'
coinuser = raw_input( "User to run %s and sqlchain daemons (will create if not existing) [%s]:" % (coin_var(DAEMON_BIN),coin_var(DEF_COIN_USER))) or coin_var(DEF_COIN_USER)
coinrpc = raw_input( "Use existing RPC user/pwd? [Y]/N:" ) or 'Y'
coinpwd = ''
if coinrpc.upper() != 'Y':
    coinrpc = raw_input( "RPC username? [%s]:" % coin_var(DEF_COIN_USER) ) or coin_var(DEF_COIN_USER)
    coinpwd = raw_input( "RPC password [create random]:" )

coinprune = 'N'
if coin_var(CAN_PRUNE):
    print """\n%s can be run in pruning mode to discard block data after sqlchaind has processed it.
This requires a bitcoind be built with 'manual pruning' to allow control over pruned blocks.
This requires version >= 0.14.1 or a custom build with PR #7871. If you do not have this mode
available then do not enable pruning as blocks could be pruned before being processed by sqlchaind.\n""" % cointype.capitalize()
    coinprune = raw_input( "Run %s in pruning mode Y/[N]:" % coin_var(DAEMON_BIN)) or 'N'

blkdat = 'N'
if coin_var(CAN_BLKDAT):
    print """\nsqlchaind can parse block files directly, bypassing RPC calls. This is faster during intial sync when the RPC
response can be very slow. Direct mode is currently experimnetal and may not be as safe.\n"""
    blkdat = raw_input( "Run sqlchaind in direct mode Y/[N]:" ) or 'N'

print """\nsqlchaind can discard signature and witness data used for validation. Many use cases don't require
this data and it can save almost 50% total disk usage to discard it.\n"""
nosigs = raw_input( "Discard signature/witness data [Y]/N:" ) or 'Y'

sqlboot = raw_input( "Start sqlchaind at system boot Y/N/[No Change]:" ) or '#'
apiboot = raw_input( "Start sqlchain-api at system boot Y/N/[No Change]:" ) or '#'
cfgdir = raw_input( "\nDirectory for config files [/etc/sqlchain]:") or "/etc/sqlchain"
sqldir = raw_input( "Directory for sqlchain log, blob and header data files [%s/%s]:" % (sqlroot,cointype)) or sqlroot+cointype

print """\nsqlchain-api can serve web pages (html,js,css) directly but for more robust SSL support and better static file 
caching and speed it's preferable to use Nginx as a front end (reverse proxy). A conf file can be created with basic settings 
but will not be overwritten if already present.\n"""
nginx = 'n'
wwwdir = raw_input( "Web root directory for sqlchain-api (N to disable, use front end) [/var/www/%s]:" % cointype) or "/var/www/"+cointype
if wwwdir in ['n','N','/','none']:
    nginx = raw_input( "Nginx reverse proxy config path [/etc/nginx/conf.d/%s.conf]:" % cointype) or "/etc/nginx/conf.d/%s.conf" % cointype
    apidomain = raw_input( "Host domain name for Nginx conf [api.%s.info]:" % cointype) or "api.%s.info" % cointype
    sslpath = raw_input( "SSL certificate path for Nginx conf [/etc/letsencrypt/live/%s]:" % apidomain) or "/etc/letsencrypt/live/%s" % apidomain
    
dbname = raw_input( "\nMySQL database name [%s]:" % cointype ) or cointype
dbuser = raw_input( "MySQL database user (will grant privileges) [%s]:" % coin_var(DEF_COIN_USER)) or coin_var(DEF_COIN_USER)
dbpwd = raw_input( "MySQL %s user password [create random]:" % dbuser )
dbeng = raw_input( "\nMySQL database engine, eg. TokuDB, Aria, InnoDB [MyISAM]:") or 'MyISAM'
rootpwd = getpass( "MySQL root password (needed to create database and user):" )

if coinpwd == '':
    coinpwd = ''.join(random.sample(string.ascii_letters+string.digits,20))
if dbpwd == '':
    dbpwd = ''.join(random.sample(string.ascii_letters+string.digits,20))

print ""

os.chdir('/usr/local/share/sqlchain')

## Create user for running coin and sqlchain daemons
try:
    pwd = pwd.getpwnam(coinuser)
except KeyError:
    print "Creating user:",coinuser
    os.system('useradd -r -s /bin/false '+coinuser)
    pwd = pwd.getpwnam(coinuser)

### Create directories if not already
if not os.path.exists(cfgdir):
    print "Creating directory:", cfgdir
    os.makedirs(cfgdir)
    os.chown(cfgdir, pwd.pw_uid, pwd.pw_gid)
if not os.path.exists(coindir):
    print "Creating directory:", coindir
    os.makedirs(coindir)
    os.chown(coindir, pwd.pw_uid, pwd.pw_gid)
if not os.path.exists(sqldir):
    print "Creating directory:", sqldir
    os.makedirs(sqldir)
    os.chown(sqldir, pwd.pw_uid, pwd.pw_gid)
if wwwdir in ['n','N','/','none']:
    wwwdir = ''
elif not os.path.exists(wwwdir):
    print "Creating directory:", wwwdir
    os.makedirs(wwwdir)
    os.chown(wwwdir, pwd.pw_uid, pwd.pw_gid)
    print "Copying demo web app files."
    for root, dirs, files in os.walk('www'):
        dst = root[root.index('/'):] if '/'  in root else '/'
        for d in dirs:
            os.mkdir(os.path.join(wwwdir+dst, d))
            os.chown(os.path.join(wwwdir+dst, d), pwd.pw_uid, pwd.pw_gid)
        for f in files:
            shutil.copy2(os.path.join(root, f), os.path.join(wwwdir+dst, f))
            os.chown(os.path.join(wwwdir+dst, f), pwd.pw_uid, pwd.pw_gid)
    democvt(os.path.join('www', 'main.html'), os.path.join(wwwdir, 'main.html'), cointype)

### Create empty data files and set ownership
for f in ['/blobs.0.dat','/hdrs.dat']:
    try:
        os.utime(sqldir+f, None)
    except OSError:
        print "Creating data file:", sqldir+f
        open(sqldir+f, 'a').close()
        os.chown(sqldir+f, pwd.pw_uid, pwd.pw_gid)

### Create MySql database and tables
sqldef = 'docs/%s.sql' % dbname         # custom dbname overrides cointype
if not os.path.exists(sqldef):
    sqldef = 'docs/%s.sql' % cointype   # cointype overrides default
if not os.path.exists(sqldef):
    sqldef = 'docs/sqlchain.sql'        # default sqlchain schema
print "Creating MySQL database: %s using schema: %s", (dbname,os.path.split(sqldef)[1])
try:
    sqlsrc = open(sqldef).read()
    sqlcode = ''
    for k,v in [('--CREATE','CREATE'),('--GRANT','GRANT'),('--ALTER','ALTER'),('--FLUSH','FLUSH'),('coindb',dbname),('sqlpwd',dbpwd),('sqluser',dbuser),('MyISAM',dbeng)]:
        sqlsrc = sqlsrc.replace(k, v)
    for line in sqlsrc.splitlines():
        if line != '' and line[:2] != '--':
            sqlcode += line

    sql = db.connect(user='root', passwd=rootpwd)
    cur = sql.cursor()
    for stmnt in sqlcode.split(';'):
        if stmnt:
            cur.execute(stmnt)
except (IOError, ImportError):
    print "Cannot open ", '/usr/local/share/sqlchain/docs/sqlchain.sql'
    print "Skipping further MySQL DB setup\n"
except db.Error, e: # pylint:disable=no-member
    print "MySQL Error: %s" % str(e)
    print "Skipping further MySQL DB setup\n"

### Create systemd services for daemon control and system boot
initsrc = """
[Unit]
Description=sqlChain - SQL layer and API (use @cointype with systemctl)

[Service]
Type=forking
ExecStart
TimeoutStopSec=2min

[Install]
WantedBy=multi-user.target

"""
coinbin = '/usr/local/bin/'+coin_var(DAEMON_BIN)
if not os.path.exists(coinbin):
    coinbin = '/usr/bin/'+coin_var(DAEMON_BIN)
if coinboot != '#':
    initfile = '/lib/systemd/system/%s.service' % cointype
    try:
        os.utime(initfile, None)
    except OSError:
        print "Creating systemd init file: %s" % initfile
        with open(initfile, 'w') as f:
            s = "ExecStart=/sbin/start-stop-daemon --start --pidfile %s/%s.pid --chuid %s:%s --exec %s -- -conf=%s/%s.conf -datadir=%s\n" % (sqldir,coin_var(DAEMON_BIN),coinuser,coinuser,coinbin,cfgdir,cointype,coindir)
            f.write(initsrc.replace('ExecStart',s))
    if coinboot.upper() == 'Y':
        os.symlink('../%s.service' % cointype, '/lib/systemd/system/multi-user.target.wants/%s.service' % cointype)
if sqlboot != '#':
    initfile = '/lib/systemd/system/sqlchain@.service'
    try:
        os.utime(initfile, None)
    except OSError:
        print "Creating systemd init file: %s" % initfile
        with open(initfile, 'w') as f:
            s = "ExecStart=/sbin/start-stop-daemon --start --pidfile %s/%%i/daemon.pid --exec /usr/local/bin/sqlchaind -- %s/sqlchain.%%i.cfg\n" % (sqlroot,cfgdir)
            f.write(initsrc.replace('Type=forking\n','').replace('ExecStart',s))
    if coinboot.upper() == 'Y':
        os.symlink('../sqlchain@.service', '/lib/systemd/system/multi-user.target.wants/sqlchain@%s.service' % cointype)
if apiboot != '#':
    initfile = '/lib/systemd/system/sqlchain-api@.service'
    try:
        os.utime(initfile, None)
    except OSError:
        print "Creating systemd init file: %s" % initfile
        with open(initfile, 'w') as f:
            s = "ExecStart=/sbin/start-stop-daemon --start --pidfile %s/%%i/api.pid --exec /usr/local/bin/sqlchain-api -- %s/sqlchain-api.%%i.cfg\n" % (sqlroot,cfgdir)
            f.write(initsrc.replace('Type=forking\n','').replace('ExecStart',s))
    if coinboot.upper() == 'Y':
        os.symlink('../sqlchain-api@.service', '/lib/systemd/system/multi-user.target.wants/sqlchain-api@%s.service' % cointype)
print """\nUse systemctl to manage the %s sqlchain daemons:
  systemctl start sqlchain@%s - start daemon
  systemctl stop sqlchain@%s - stop daemon
  systemctl enable sqlchain@%s - enable daemon start at boot
  systemctl disable sqlchain@%s - disable daemon starting at boot
  systemctl status sqlchain@%s - daemon status, debug why it isn't running
and similarly systemctl ... sqlchain-api@%s with same commands for the api daemon
""".replace('%s', cointype)

### Create or update the blockchain node conf
cfgcoin = {}
try:
    conf = open(cfgdir+'/%s.conf' % cointype).read()
    print "Updating file: %s/%s.conf" % (cfgdir,cointype)
    for line in conf.splitlines():
        if '=' in line:
            k,v = line.split('=')
            cfgcoin[k] = v
except (IOError, ImportError):
    print "Creating file: %s/%s.conf" % (cfgdir,cointype)

cfgcoin.update({'server':1, 'daemon':1, 'prune':1 if coinprune.upper() == 'Y' else 0, 'rpcport':coin_var(DEF_RPC_PORT), \
              'datadir':coindir, 'pid':sqldir+'/%s.pid' % coin_var(DAEMON_BIN), 'disablewallet':1 })
if coinrpc.upper() != 'Y':
    cfgcoin.update({'rpcuser':coinrpc, 'rpcpassword':coinpwd })
elif 'rpcuser' not in cfgcoin:
    cfgcoin.update({'rpcuser':'%s' % coin_var(DEF_COIN_USER), 'rpcpassword':coinpwd })
if cointype == 'testnet':
    cfgcoin.update({'testnet':1 })

with open(cfgdir+'/%s.conf' % cointype, 'w') as f:
    for k in cfgcoin:
        f.write("%s=%s\n" % (k,cfgcoin[k]))
os.chown(cfgdir+'/%s.conf' % cointype, pwd.pw_uid, pwd.pw_gid)
os.chmod(cfgdir+'/%s.conf' % cointype, 0660)

### Create sqlchaind.cfg
sqlcfg = { "log": sqldir+"/daemon.log", "pid": sqldir+"/daemon.pid", "path": sqldir, "db": "localhost:%s:%s:%s" % (dbuser,dbpwd,dbname), \
           "queue": 8, "rpc": "http://%s:%s@localhost:%d" % (cfgcoin['rpcuser'],cfgcoin['rpcpassword'],coin_var(DEF_RPC_PORT)), \
           "debug": False, "user": coinuser, "no-sigs": nosigs.upper() == 'Y', "cointype": cointype }
if blkdat.upper() == 'Y':
    sqlcfg["blkdat"] = coindir + '/' + coin_var(BLKDAT_DIR)
print "Creating config file:", cfgdir+'/sqlchain.%s.cfg' % cointype
with open(cfgdir+'/sqlchain.%s.cfg' % cointype, 'w') as f:
    json.dump(sqlcfg, f, indent=2)
os.chown(cfgdir+'/sqlchain.%s.cfg' % cointype, pwd.pw_uid, pwd.pw_gid)
os.chmod(cfgdir+'/sqlchain.%s.cfg' % cointype, 0660)

### Create sqlchain-api.cfg
apicfg = { "www": wwwdir, "user": coinuser, "db": "localhost:%s:%s:%s" % (dbuser,dbpwd,dbname), "dbinfo": -1, "dbinfo-ts": "0", \
           "rpc": "http://%s:%s@localhost:%d" % (cfgcoin['rpcuser'],cfgcoin['rpcpassword'],coin_var(DEF_RPC_PORT)), \
           "pool": 4, "log": sqldir+"/api.log", "pid": sqldir+"/api.pid", "cointype": cointype, \
           "path": sqldir, "debug": False, "block": 0, "listen": "localhost:%d" % coin_var(DEF_API_PORT), "sync": 0 }
print "Creating config file:", cfgdir+'/sqlchain-api.%s.cfg' % cointype
with open(cfgdir+'/sqlchain-api.%s.cfg' % cointype, 'w') as f:
    json.dump(apicfg, f, indent=2)
os.chown(cfgdir+'/sqlchain-api.%s.cfg' % cointype, pwd.pw_uid, pwd.pw_gid)
os.chmod(cfgdir+'/sqlchain-api.%s.cfg' % cointype, 0660)

### Create log rotation control files
print "Creating logrotate files in: /etc/logrotate.d/"
logconf = """
sqldir/*.log {
    weekly
    rotate 4
    compress
    delaycompress
    missingok
    notifempty
    postrotate
        [ -f sqldir/api.pid ] && kill -HUP `cat sqldir/api.pid`
        [ -f sqldir/daemon.pid ] && kill -HUP `cat sqldir/daemon.pid`
    endscript
}
"""
logconfpath = '/etc/logrotate.d/sqlchain.%s' % cointype
if not os.path.exists(logconfpath):
    with open(logconfpath, 'w') as f:
        f.write(logconf.replace('sqldir', sqldir))
logconf = """
%s/debug.log {
    weekly
    copytruncate
    rotate 4
    compress
    delaycompress
    missingok
    notifempty
}
"""
logconfpath = '/etc/logrotate.d/%s' % cointype
if not os.path.exists(logconfpath):
    with open(logconfpath, 'w') as f:
        f.write(logconf % coindir)

### Create nginx reverse proxy config
nginxconf = """
server {
    listen 80;
    listen [::]:80;
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name %s;

    ssl_certificate %s/fullchain.pem;
    ssl_certificate_key %s/privkey.pem;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;

    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_pass http://%s;
    }
}
"""
if not nginx in ['n','N','/','none']:
    nginx_path,_ = os.path.split(nginx)
    if not os.path.exists(nginx_path):
        print "Creating directory:", nginx_path
        os.makedirs(nginx_path)
    try:
        os.utime(nginx, None)
        print "Nginx reverse proxy config exists, not modified:", nginx
    except OSError:
        print "Creating nginx reverse proxy config:", nginx
        with open(nginx, 'w') as f:
            f.write(nginxconf % (apidomain,sslpath,sslpath,apicfg['listen']))
